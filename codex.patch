 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/Source/MainComponent.cpp b/Source/MainComponent.cpp
index 40acb85e682627cdba7a2c9c1edfd9ca62d7dcfc..cc4f09ded9a5e81f5be2da0ee35605bf4bf59758 100644
--- a/Source/MainComponent.cpp
+++ b/Source/MainComponent.cpp
@@ -1,163 +1,218 @@
 #include "MainComponent.h"
 
 namespace
 {
     class GreyPlaceholder final : public juce::Component
     {
     public:
         void paint (juce::Graphics& g) override
         {
             g.fillAll (juce::Colours::darkgrey);
         }
     };
 
-    class GridPlaceholder final : public juce::Component
+    class GridCell final : public juce::Component
     {
     public:
+        explicit GridCell (int indexToDraw)
+            : index (indexToDraw)
+        {
+        }
+
         void paint (juce::Graphics& g) override
         {
-            g.fillAll (juce::Colours::darkgrey);
+            g.fillAll (juce::Colours::grey);
+            g.setColour (juce::Colours::white);
+            g.drawText (juce::String (index), getLocalBounds(), juce::Justification::centred);
+        }
 
-            const int cellW = 150;
-            const int cellH = 64;
-            const int spacing = 3;
+    private:
+        int index = 0;
+    };
 
-            g.setColour (juce::Colours::grey);
+    class PreviewGrid final : public juce::Component
+    {
+    public:
+        PreviewGrid()
+        {
+            for (int index = 0; index < totalCells; ++index)
+            {
+                auto cell = std::make_unique<GridCell> (index);
+                addAndMakeVisible (*cell);
+                cells.add (std::move (cell));
+            }
+        }
 
-            for (int row = 0; row < 4; ++row)
+        void resized() override
+        {
+            for (int row = 0; row < rows; ++row)
             {
-                for (int col = 0; col < 4; ++col)
+                for (int col = 0; col < columns; ++col)
                 {
+                    const int index = row * columns + col;
                     const int x = col * (cellW + spacing);
                     const int y = row * (cellH + spacing);
-                    g.fillRect (x, y, cellW, cellH);
+                    cells[index]->setBounds (x, y, cellW, cellH);
                 }
             }
         }
+
+    private:
+        static constexpr int columns = 4;
+        static constexpr int rows = 4;
+        static constexpr int totalCells = columns * rows;
+        static constexpr int cellW = 150;
+        static constexpr int cellH = 64;
+        static constexpr int spacing = 3;
+
+        juce::OwnedArray<GridCell> cells;
     };
 
     class PersistentFrame final : public juce::Component,
                                   private juce::ChangeListener
     {
     public:
         explicit PersistentFrame (juce::TabbedComponent& tabsToTrack)
             : tabs (tabsToTrack)
         {
             addAndMakeVisible (focusPlaceholder);
-            addAndMakeVisible (gridPlaceholder);
+            addAndMakeVisible (grid);
             addAndMakeVisible (bottomPlaceholder);
             tabs.getTabbedButtonBar().addChangeListener (this);
+
+            // Settings bypass path: hide frame while Settings tab is active.
             setVisible (tabs.getCurrentTabName() != "SETTINGS");
         }
 
         ~PersistentFrame() override
         {
             tabs.getTabbedButtonBar().removeChangeListener (this);
         }
 
+        void paint (juce::Graphics& g) override
+        {
+            // TEMP SCAFFOLDING: persistent frame region fill.
+            g.fillAll (juce::Colours::darkslategrey);
+            g.setColour (juce::Colours::white);
+            g.drawText ("FRAME", getLocalBounds(), juce::Justification::centred);
+        }
+
         void resized() override
         {
             const int focusW = 609;
             const int focusH = 96;
             const int gridW = 609;
             const int gridH = 4 * 64 + 3 * 3;
             const int spacing = 6;
             const int bottomH = 25;
 
             int y = 0;
             focusPlaceholder.setBounds (0, y, focusW, focusH);
             y += focusH + spacing;
-            gridPlaceholder.setBounds (0, y, gridW, gridH);
+            grid.setBounds (0, y, gridW, gridH);
             y += gridH + spacing;
             bottomPlaceholder.setBounds (0, y, gridW, bottomH);
         }
 
     private:
         void changeListenerCallback (juce::ChangeBroadcaster*) override
         {
+            // Settings bypass path: hide frame while Settings tab is active.
             setVisible (tabs.getCurrentTabName() != "SETTINGS");
         }
 
         juce::TabbedComponent& tabs;
         GreyPlaceholder focusPlaceholder;
-        GridPlaceholder gridPlaceholder;
+        PreviewGrid grid;
         GreyPlaceholder bottomPlaceholder;
     };
 
     class TabHeaderContainer final : public juce::Component,
                                      private juce::ChangeListener
     {
     public:
         explicit TabHeaderContainer (juce::TabbedComponent& tabsToTrack)
             : tabs (tabsToTrack)
         {
             addAndMakeVisible (mainHeader);
             addAndMakeVisible (globalHeader);
             addAndMakeVisible (localHeader);
             addAndMakeVisible (liveHeader);
 
             tabs.getTabbedButtonBar().addChangeListener (this);
             updateVisibleHeader();
         }
 
         ~TabHeaderContainer() override
         {
             tabs.getTabbedButtonBar().removeChangeListener (this);
         }
 
         void setLiveContent (juce::Component* content)
         {
             if (content != nullptr)
                 liveHeader.addAndMakeVisible (content);
         }
 
+        void paint (juce::Graphics& g) override
+        {
+            // TEMP SCAFFOLDING: header region fill.
+            g.fillAll (juce::Colours::darkred);
+            g.setColour (juce::Colours::white);
+            g.drawText ("HEADER", getLocalBounds(), juce::Justification::centred);
+        }
+
         void resized() override
         {
             const auto bounds = getLocalBounds();
             mainHeader.setBounds (bounds);
             globalHeader.setBounds (bounds);
             localHeader.setBounds (bounds);
             liveHeader.setBounds (bounds);
         }
 
     private:
         void changeListenerCallback (juce::ChangeBroadcaster*) override
         {
             updateVisibleHeader();
         }
 
         void updateVisibleHeader()
         {
             const auto currentTab = tabs.getCurrentTabName();
 
+            // Header region ownership (per-tab visibility).
             const bool showMain = currentTab == "MAIN";
             const bool showGlobal = currentTab == "GLOBAL";
             const bool showLocal = currentTab == "LOCAL";
             const bool showLive = currentTab == "LIVE";
 
+            // Settings bypass path: hide header while Settings tab is active.
             setVisible (currentTab != "SETTINGS");
+
+            // Centralized header visibility toggles.
             mainHeader.setVisible (showMain);
             globalHeader.setVisible (showGlobal);
             localHeader.setVisible (showLocal);
             liveHeader.setVisible (showLive);
         }
 
         juce::TabbedComponent& tabs;
         GreyPlaceholder mainHeader;
         GreyPlaceholder globalHeader;
         GreyPlaceholder localHeader;
         juce::Component liveHeader;
     };
 }
 
 // =======================
 // SETTINGS VIEW
 // =======================
 
 SettingsView::SettingsView (AudioEngine& engine)
     : audioEngine (engine)
 {
     deviceSelector = std::unique_ptr<juce::AudioDeviceSelectorComponent>(
         new juce::AudioDeviceSelectorComponent (
             audioEngine.getDeviceManager(),
             0, 256,   // allow inputs
@@ -198,50 +253,50 @@ MainComponent::MainComponent (AudioEngine& engine)
                  juce::Colours::darkgrey,
                  new juce::Component(),
                  true);
 
     tabs.addTab ("GLOBAL",
                  juce::Colours::darkgrey,
                  new juce::Component(),
                  true);
 
     tabs.addTab ("LOCAL",
                  juce::Colours::darkgrey,
                  new juce::Component(),
                  true);
 
     tabs.addTab ("LIVE",
                  juce::Colours::darkgrey,
                  new juce::Component(),
                  true);
 
     tabs.addTab ("SETTINGS",
                  juce::Colours::darkgrey,
                  &settingsView,
                  false);
 
     addAndMakeVisible (tabs);
-    
+
 }
 
 void MainComponent::resized()
 {
     tabs.setBounds (getLocalBounds());
 
     const int headerH = 25;
 
     if (auto* frame = findChildWithID ("persistentFrame"))
     {
         const int focusH = 96;
         const int gridH = 4 * 64 + 3 * 3;
         const int spacing = 6;
         const int bottomH = 25;
         const int frameH = focusH + spacing + gridH + spacing + bottomH;
 
         frame->setBounds (0, headerH, 609, frameH);
     }
 
     if (auto* headers = findChildWithID ("tabHeaders"))
     {
         headers->setBounds (0, 0, 609, headerH);
     }
-}
\ No newline at end of file
+}
 
EOF
)